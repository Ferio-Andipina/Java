import java.net.HttpURLConnection;
import java.net.URL;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import javax.imageio.ImageIO;
import javax.swing.*;
import javax.swing.border.TitledBorder;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class MainGUI extends JFrame {
    private JPanel figurePanel;
    private JScrollPane figureScrollPane;
    private DrawingPanel drawingPanel;
    private List<FigureItem> currentFigures = new ArrayList<>();

    volatile boolean running = false;
    final Object figuresLock = new Object();

    // Потоки
    private List<Thread> moverThreads = new ArrayList<>();
    private Thread renderThread;

    public MainGUI() {
        setTitle("Редактор фигур");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setSize(1000, 600);
        setLocationRelativeTo(null);

        // === Верхняя панель с кнопками ===
        JPanel topPanel = new JPanel(new BorderLayout());

        JPanel leftButtons = new JPanel(new FlowLayout(FlowLayout.LEFT));
        JButton openTextButton = new JButton("Открыть (текст)");
        JButton closeTextButton = new JButton("Закрыть");
        JButton loadJsonButton = new JButton("Загрузить JSON");
        JButton saveJsonButton = new JButton("Сохранить JSON");
        leftButtons.add(openTextButton);
        leftButtons.add(closeTextButton);
        leftButtons.add(loadJsonButton);
        leftButtons.add(saveJsonButton);

        JPanel centerButtons = new JPanel();

        JPanel rightButtons = new JPanel(new FlowLayout(FlowLayout.RIGHT));
        JButton saveDbButton = new JButton("Сохранить в БД");
        JButton loadDbButton = new JButton("Загрузить из БД");
        JButton saveImageButton = new JButton("Сохранить PNG");
        JButton startThreadsButton = new JButton("Старт потоков");
        JButton stopThreadsButton = new JButton("Стоп потоков");
        JButton exitButton = new JButton("Выйти");

        rightButtons.add(saveDbButton);
        rightButtons.add(loadDbButton);
        rightButtons.add(saveImageButton);
        rightButtons.add(startThreadsButton);
        rightButtons.add(stopThreadsButton);
        rightButtons.add(exitButton);

	JButton webSaveButton = new JButton("Сохранить в Web");
	JButton webLoadButton = new JButton("Загрузить из Web");
	leftButtons.add(webSaveButton);
	leftButtons.add(webLoadButton);

	webSaveButton.addActionListener(e -> saveToWeb());
	webLoadButton.addActionListener(e -> loadFromWeb());

        topPanel.add(leftButtons, BorderLayout.WEST);
        topPanel.add(centerButtons, BorderLayout.CENTER);
        topPanel.add(rightButtons, BorderLayout.EAST);

        // === Левая панель: чекбоксы ===
        figurePanel = new JPanel();
        figurePanel.setLayout(new BoxLayout(figurePanel, BoxLayout.Y_AXIS));
        figurePanel.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
        figureScrollPane = new JScrollPane(figurePanel);
        figureScrollPane.setBorder(BorderFactory.createTitledBorder("Фигуры"));

        // === Правая панель: рисование ===
        drawingPanel = new DrawingPanel();

        // === Разделение ===
        JSplitPane centerSplit = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, figureScrollPane, drawingPanel);
        centerSplit.setDividerLocation(350);

        // === Сборка ===
        setLayout(new BorderLayout());
        add(topPanel, BorderLayout.NORTH);
        add(centerSplit, BorderLayout.CENTER);

        // === Обработчики кнопок ===
        openTextButton.addActionListener(e -> openTextFile());
        closeTextButton.addActionListener(e -> clearFigures());
        loadJsonButton.addActionListener(e -> loadJsonFile());
        saveJsonButton.addActionListener(e -> saveJsonFile());
        saveDbButton.addActionListener(e -> saveToDatabase());
        loadDbButton.addActionListener(e -> loadFromDatabase());
        saveImageButton.addActionListener(e -> saveImage());
        startThreadsButton.addActionListener(e -> startThreads());
        stopThreadsButton.addActionListener(e -> stopThreads());
        exitButton.addActionListener(e -> System.exit(0));
    }

	private void saveToWeb() {
	    List<ColoredPolygon> visible = currentFigures.stream()
	        .filter(FigureItem::isVisible)
	        .map(FigureItem::getFigure)
	        .collect(Collectors.toList());

	    if (visible.isEmpty()) {
	        JOptionPane.showMessageDialog(this, "Нет фигур для сохранения!");
	        return;
	    }

	    new Thread(() -> {
	        try {
	            URL url = new URL("http://localhost:8080/figures");
        	    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
	            conn.setRequestMethod("POST");
	            conn.setDoOutput(true);
	            conn.setRequestProperty("Content-Type", "application/octet-stream");

	            try (ObjectOutputStream oos = new ObjectOutputStream(conn.getOutputStream())) {
	                oos.writeObject(visible);
	            }

	            int responseCode = conn.getResponseCode();
	            if (responseCode == 200) {
	                SwingUtilities.invokeLater(() ->
	                    JOptionPane.showMessageDialog(this, "Фигуры сохранены на сервере!"));
	            } else {
        	        String msg = new String(conn.getErrorStream().readAllBytes());
	                throw new IOException("Server error: " + msg);
	            }
	        } catch (Exception ex) {
	            ex.printStackTrace();
	            SwingUtilities.invokeLater(() ->
	                JOptionPane.showMessageDialog(this, "Ошибка сохранения:\n" + ex.getMessage()));
	        }
	    }).start();
	}

	private void loadFromWeb() {
	    new Thread(() -> {
	        try {
	            URL url = new URL("http://localhost:8080/figures");
	            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
	            conn.setRequestMethod("GET");

	            if (conn.getResponseCode() == 200) {
	                try (ObjectInputStream ois = new ObjectInputStream(conn.getInputStream())) {
	                    @SuppressWarnings("unchecked")
	                    List<ColoredPolygon> figures = (List<ColoredPolygon>) ois.readObject();
	                    SwingUtilities.invokeLater(() -> {
	                        loadFigures(figures);
	                        JOptionPane.showMessageDialog(this, "Фигуры загружены с сервера!");
	                    });
	                }
	            } else {
	                throw new IOException("Server returned: " + conn.getResponseCode());
	            }
	        } catch (Exception ex) {
	            ex.printStackTrace();
	            SwingUtilities.invokeLater(() ->
	                JOptionPane.showMessageDialog(this, "Ошибка загрузки:\n" + ex.getMessage()));
	        }
	    }).start();
	}

    // --- ТЕКСТОВЫЙ ФОРМАТ ---
    private void openTextFile() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Выберите текстовый файл с фигурами");
        int result = fileChooser.showOpenDialog(this);
        if (result == JFileChooser.APPROVE_OPTION) {
            try {
                List<ColoredPolygon> figures = FigureFileParser.loadFiguresFromFile(
                    fileChooser.getSelectedFile().getAbsolutePath()
                );
                loadFigures(figures);
            } catch (IOException ex) {
                JOptionPane.showMessageDialog(this, "Ошибка чтения файла:\n" + ex.getMessage(), "Ошибка", JOptionPane.ERROR_MESSAGE);
            } catch (InvalidPolygonException ex) {
                JOptionPane.showMessageDialog(this, "Некорректные данные в файле:\n" + ex.getMessage(), "Ошибка", JOptionPane.ERROR_MESSAGE);
            }
        }
    }

    // --- JSON ---
    private void loadJsonFile() {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Загрузить фигуры из JSON");
        fileChooser.setSelectedFile(new File("figures.json"));
        int result = fileChooser.showOpenDialog(this);
        if (result == JFileChooser.APPROVE_OPTION) {
            try {
                List<ColoredPolygon> figures = JsonFigureIO.loadFiguresFromJson(
                    fileChooser.getSelectedFile().getAbsolutePath()
                );
                loadFigures(figures);
            } catch (IOException ex) {
                JOptionPane.showMessageDialog(this, "Ошибка чтения JSON:\n" + ex.getMessage(), "Ошибка", JOptionPane.ERROR_MESSAGE);
            } catch (InvalidPolygonException ex) {
                JOptionPane.showMessageDialog(this, "Некорректные данные:\n" + ex.getMessage(), "Ошибка", JOptionPane.ERROR_MESSAGE);
            }
        }
    }

    private void saveJsonFile() {
        List<ColoredPolygon> toSave = currentFigures.stream()
            .filter(FigureItem::isVisible)
            .map(FigureItem::getFigure)
            .collect(Collectors.toList());

        if (toSave.isEmpty()) {
            JOptionPane.showMessageDialog(this, "Нет видимых фигур для сохранения!", "Предупреждение", JOptionPane.WARNING_MESSAGE);
            return;
        }

        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Сохранить фигуры в JSON");
        fileChooser.setSelectedFile(new File("figures.json"));
        int result = fileChooser.showSaveDialog(this);
        if (result == JFileChooser.APPROVE_OPTION) {
            File file = fileChooser.getSelectedFile();
            if (!file.getName().toLowerCase().endsWith(".json")) {
                file = new File(file.getPath() + ".json");
            }
            try {
                JsonFigureIO.saveFiguresToJson(toSave, file.getAbsolutePath());
                JOptionPane.showMessageDialog(this, "Фигуры сохранены в:\n" + file.getAbsolutePath(), "Успех", JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                JOptionPane.showMessageDialog(this, "Ошибка записи JSON:\n" + ex.getMessage(), "Ошибка", JOptionPane.ERROR_MESSAGE);
            }
        }
    }

    // --- SQLite ---
    private void saveToDatabase() {
        List<ColoredPolygon> visibleFigures = currentFigures.stream()
            .filter(FigureItem::isVisible)
            .map(FigureItem::getFigure)
            .collect(Collectors.toList());

        if (visibleFigures.isEmpty()) {
            JOptionPane.showMessageDialog(this, "Нет видимых фигур для сохранения!", "Предупреждение", JOptionPane.WARNING_MESSAGE);
            return;
        }

        try {
            BufferedImage image = drawingPanel.createImage();
            SqliteFigureIO.saveToDatabase(visibleFigures, image);
            JOptionPane.showMessageDialog(this, "Фигуры и изображение сохранены в figures.db", "Успех", JOptionPane.INFORMATION_MESSAGE);
        } catch (Exception ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(this, "Ошибка сохранения в БД:\n" + ex.getMessage(), "Ошибка", JOptionPane.ERROR_MESSAGE);
        }
    }

    private void loadFromDatabase() {
        try {
            List<ColoredPolygon> figures = SqliteFigureIO.loadFromDatabase();
            if (figures.isEmpty()) {
                JOptionPane.showMessageDialog(this, "База данных пуста!", "Информация", JOptionPane.INFORMATION_MESSAGE);
                return;
            }
            loadFigures(figures);
            JOptionPane.showMessageDialog(this, "Фигуры загружены из figures.db", "Успех", JOptionPane.INFORMATION_MESSAGE);
        } catch (Exception ex) {
            ex.printStackTrace();
            JOptionPane.showMessageDialog(this, "Ошибка загрузки из БД:\n" + ex.getMessage(), "Ошибка", JOptionPane.ERROR_MESSAGE);
        }
    }

    // --- Общая загрузка фигур ---
    private void loadFigures(List<ColoredPolygon> figures) {
        figurePanel.removeAll();
        currentFigures.clear();

        for (ColoredPolygon fig : figures) {
            FigureItem item = new FigureItem(fig);
            currentFigures.add(item);

            JCheckBox checkBox = new JCheckBox(item.toString());
            checkBox.setSelected(true);
            // Лямбда-выражение
            checkBox.addActionListener(e -> {
                item.setVisible(checkBox.isSelected());
                drawingPanel.repaint();
            });

            checkBox.setAlignmentX(Component.LEFT_ALIGNMENT);
            figurePanel.add(checkBox);
        }

        figurePanel.revalidate();
        figurePanel.repaint();
        drawingPanel.repaint();
    }

    private void clearFigures() {
        figurePanel.removeAll();
        currentFigures.clear();
        figurePanel.revalidate();
        figurePanel.repaint();
        drawingPanel.repaint();
    }

    // --- Сохранение изображения ---
    private void saveImage() {
        if (currentFigures.isEmpty()) {
            JOptionPane.showMessageDialog(this, "Нет фигур для сохранения!", "Предупреждение", JOptionPane.WARNING_MESSAGE);
            return;
        }

        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle("Сохранить изображение как...");
        fileChooser.setSelectedFile(new File("figures.png"));
        int result = fileChooser.showSaveDialog(this);
        if (result == JFileChooser.APPROVE_OPTION) {
            File file = fileChooser.getSelectedFile();
            if (!file.getName().toLowerCase().endsWith(".png")) {
                file = new File(file.getPath() + ".png");
            }

            try {
                BufferedImage image = drawingPanel.createImage();
                ImageIO.write(image, "png", file);
                JOptionPane.showMessageDialog(this, "Изображение сохранено:\n" + file.getAbsolutePath(), "Успех", JOptionPane.INFORMATION_MESSAGE);
            } catch (IOException ex) {
                JOptionPane.showMessageDialog(this, "Ошибка сохранения:\n" + ex.getMessage(), "Ошибка", JOptionPane.ERROR_MESSAGE);
            }
        }
    }

    // --- Многопоточность ---
    private void startThreads() {
        if (running) {
            JOptionPane.showMessageDialog(this, "Потоки уже запущены!", "Информация", JOptionPane.INFORMATION_MESSAGE);
            return;
        }

        if (currentFigures.isEmpty()) {
            JOptionPane.showMessageDialog(this, "Нет фигур для анимации!", "Ошибка", JOptionPane.WARNING_MESSAGE);
            return;
        }

        String input = JOptionPane.showInputDialog(this,
            "Введите количество потоков (от 2 до 10):", "5");
        if (input == null) return;

        int threadCount;
        try {
            threadCount = Integer.parseInt(input);
            if (threadCount < 2 || threadCount > 10) {
                throw new NumberFormatException();
            }
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(this, "Введите число от 2 до 10!", "Ошибка", JOptionPane.ERROR_MESSAGE);
            return;
        }

        running = true;
        moverThreads.clear();

        for (int i = 0; i < threadCount; i++) {
            Thread mover = new Thread(new FigureMover(), "Mover-" + i);
            mover.setDaemon(true);
            mover.start();
            moverThreads.add(mover);
        }

        renderThread = new Thread(() -> {
            try {
                while (running) {
                    Thread.sleep(500);
                    SwingUtilities.invokeLater(drawingPanel::repaint);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }, "Renderer");
        renderThread.setDaemon(true);
        renderThread.start();

        JOptionPane.showMessageDialog(this, "Запущено " + threadCount + " потоков + рендерер.", "Успех", JOptionPane.INFORMATION_MESSAGE);
    }

    private void stopThreads() {
        if (!running) {
            JOptionPane.showMessageDialog(this, "Потоки не запущены!", "Информация", JOptionPane.INFORMATION_MESSAGE);
            return;
        }

        running = false;
        moverThreads.clear();
        renderThread = null;

        JOptionPane.showMessageDialog(this, "Потоки остановлены.", "Информация", JOptionPane.INFORMATION_MESSAGE);
    }

    // === Внутренний класс: панель рисования ===
    private class DrawingPanel extends JPanel {
        private FigureItem selectedFigure = null;
        private int dragOffsetX = 0;
        private int dragOffsetY = 0;
        private java.awt.Polygon dragPreview = null;

        public DrawingPanel() {
            setBorder(BorderFactory.createTitledBorder("Рисунок"));
            setBackground(Color.WHITE);
            addMouseListener(new MouseAdapter() {
                @Override
                public void mousePressed(MouseEvent e) {
                    handleMousePressed(e);
                }

                @Override
                public void mouseReleased(MouseEvent e) {
                    handleMouseReleased(e);
                }
            });
            addMouseMotionListener(new MouseAdapter() {
                @Override
                public void mouseDragged(MouseEvent e) {
                    handleMouseDragged(e);
                }
            });
        }

        private void handleMousePressed(MouseEvent e) {
            int x = e.getX();
            int y = e.getY();

            FigureItem clicked = null;
            for (int i = currentFigures.size() - 1; i >= 0; i--) {
                FigureItem item = currentFigures.get(i);
                if (item.isVisible() && item.getFigure().contains(x, y)) {
                    clicked = item;
                    break;
                }
            }

            if (clicked != null) {
                selectedFigure = clicked;
                currentFigures.remove(selectedFigure);
                currentFigures.add(selectedFigure);

                java.awt.Polygon poly = selectedFigure.getFigure().getAWTPolygon();
                dragOffsetX = x - poly.getBounds().x;
                dragOffsetY = y - poly.getBounds().y;

                repaint();
            } else {
                selectedFigure = null;
                repaint();
            }
        }

        private void handleMouseDragged(MouseEvent e) {
            if (selectedFigure != null) {
                if (dragPreview != null) {
                    Graphics g = getGraphics();
                    if (g != null) {
                        g.setXORMode(Color.WHITE);
                        g.drawPolygon(dragPreview);
                        g.dispose();
                    }
                }

                int mouseX = e.getX();
                int mouseY = e.getY();
                java.awt.Polygon original = selectedFigure.getFigure().getAWTPolygon();
                Rectangle bounds = original.getBounds();

                int newX = mouseX - dragOffsetX;
                int newY = mouseY - dragOffsetY;

                dragPreview = new java.awt.Polygon();
                int dx = newX - bounds.x;
                int dy = newY - bounds.y;
                for (int i = 0; i < original.npoints; i++) {
                    dragPreview.addPoint(original.xpoints[i] + dx, original.ypoints[i] + dy);
                }

                Graphics g = getGraphics();
                if (g != null) {
                    g.setXORMode(Color.BLACK);
                    g.drawPolygon(dragPreview);
                    g.dispose();
                }
            }
        }

        private void handleMouseReleased(MouseEvent e) {
            if (selectedFigure != null && dragPreview != null) {
                Graphics g = getGraphics();
                if (g != null) {
                    g.setXORMode(Color.WHITE);
                    g.drawPolygon(dragPreview);
                    g.dispose();
                }

                java.awt.Polygon original = selectedFigure.getFigure().getAWTPolygon();
                int dx = dragPreview.getBounds().x - original.getBounds().x;
                int dy = dragPreview.getBounds().y - original.getBounds().y;

                selectedFigure.getFigure().moveBy(dx, dy);
                dragPreview = null;
                repaint();
            }
        }

        @Override
        protected void paintComponent(Graphics g) {
            super.paintComponent(g);
            Graphics2D g2d = (Graphics2D) g;
            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

            for (FigureItem item : currentFigures) {
                if (item.isVisible()) {
                    ColoredPolygon fig = item.getFigure();
                    java.awt.Polygon poly = fig.getAWTPolygon();

                    g2d.setColor(fig.getFillColor());
                    g2d.fillPolygon(poly);

                    g2d.setColor(fig.getLineColor());
                    g2d.setStroke(new BasicStroke(2));
                    g2d.drawPolygon(poly);

                    if (item == selectedFigure) {
                        g2d.setColor(Color.BLUE);
                        g2d.setStroke(new BasicStroke(1, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 0, new float[]{5}, 0));
                        g2d.draw(poly.getBounds());
                    }
                }
            }
        }

        public BufferedImage createImage() {
            synchronized (figuresLock) {
                int w = getWidth();
                int h = getHeight();
                if (w <= 0 || h <= 0) {
                    w = 800;
                    h = 600;
                }
                BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);
                Graphics2D g2d = image.createGraphics();
                g2d.setColor(Color.WHITE);
                g2d.fillRect(0, 0, w, h);
                g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

                for (FigureItem item : currentFigures) {
                    if (item.isVisible()) {
a                        ColoredPolygon fig = item.getFigure();
                        java.awt.Polygon poly = fig.getAWTPolygon();

                        g2d.setColor(fig.getFillColor());
                        g2d.fillPolygon(poly);

                        g2d.setColor(fig.getLineColor());
                        g2d.setStroke(new BasicStroke(2));
                        g2d.drawPolygon(poly);
                    }
                }
                g2d.dispose();
                return image;
            }
        }
    }

    // === Внутренний класс: поток-двигатель ===
    private class FigureMover implements Runnable {
        private final int dx;
        private final int dy;
        private final long delayMs;

        public FigureMover() {
            this.dx = getRandomShift();
            this.dy = getRandomShift();
            this.delayMs = 500 + (long)(Math.random() * 9500);
        }

        private int getRandomShift() {
            int value = 1 + (int)(Math.random() * 5);
            return Math.random() < 0.5 ? -value : value;
        }

        @Override
        public void run() {
            try {
                while (running) {
                    Thread.sleep(delayMs);

                    List<FigureItem> visible = currentFigures.stream()
                        .filter(FigureItem::isVisible)
                        .collect(Collectors.toList());

                    if (visible.isEmpty()) continue;

                    FigureItem item = visible.get((int)(Math.random() * visible.size()));
                    ColoredPolygon fig = item.getFigure();

                    synchronized (figuresLock) {
                        java.awt.Polygon poly = fig.getAWTPolygon();
                        Rectangle bounds = poly.getBounds();

                        int newX = bounds.x + dx;
                        int newY = bounds.y + dy;

                        int panelWidth = drawingPanel.getWidth();
                        int panelHeight = drawingPanel.getHeight();

                        if (panelWidth <= 0 || panelHeight <= 0) continue;

                        if (newX < 0) newX = 0;
                        if (newY < 0) newY = 0;
                        if (newX + bounds.width > panelWidth) {
                            newX = panelWidth - bounds.width;
                        }
                        if (newY + bounds.height > panelHeight) {
                            newY = panelHeight - bounds.height;
                        }

                        int actualDx = newX - bounds.x;
                        int actualDy = newY - bounds.y;

                        if (actualDx != 0 || actualDy != 0) {
                            fig.moveBy(actualDx, actualDy);
                        }
                    }
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            try {
                UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
            } catch (Exception e) {
                e.printStackTrace();
            }
            new MainGUI().setVisible(true);
        });
    }
}

